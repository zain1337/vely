#!/bin/bash
#SPDX-License-Identifier: EPL-2.0
#Copyright 2019 DaSoftver LLC. Written by Sergio Mijatovic. 
#Licensed under Eclipse Public License - v 2.0. See LICENSE file.
#On the web https://vely.dev/ - this file is part of Vely framework.

#variable names for Vely start with VV_ (VV_C_ being compiling-related) and _ (internal)

#
#
#make script for Vely application
#
#

#
#Set one or the other
#
#_BETA=""

export VV_USER=$(whoami)
#make sure HOME is available, some apps wipe it out like apache setenv
if [ "$HOME" == "" ]; then
    HOME=$(eval echo ~$VV_USER)
fi

#cannot run as run as it might mess up permissions. 
if [[ $EUID -eq 0 ]]; then echo "You cannot run vely as root or sudo"; exit -1; fi

#enable "extended globs" (such as "parameter expansion" or ${!X}
shopt -s extglob

#display error context if vely has a shell error, source file bash only
set -eE -o functrace
trap 'echo "Error: status $?, $(caller), line ${BASH_SOURCE[0]}/${LINENO}"' ERR

#do not change these values, they are changed here by Makefile per platform when make install is done
export VV_LIBRARY_PATH=/usr/lib/vely
. "$VV_LIBRARY_PATH"/sys
#end of do-not-change

#by default, make is silent (except for messages we emit). For debugging, use -e to see everything that's going on (this shows vely execution too!)
VV_SHOW_MAKE="-s"

#location of Vely data
export VV_DATA="/var/lib/vv"

export VV_C_RESTPATH=""
export VV_C_MAXUPLOAD="25000000"
export VV_C_MAXERRORS="5"
#plain diagnostics must have value, as it's passed in a script (vdiag) in vmakefile
export VV_C_PLAINDIAG="0"

#defaults for quick install
_PROXYPORT="80"

#display Vely usage
#Internal: 
#--asan build with ASAN
#--asan-opt print out ASAN option to prefix the execution with, also works with prefix vf for better coverage of FCGI program
function use_message() {
    echo "Usage: $0  OPTIONS 
OPTIONS:

-c      clean make artifacts for a rebuild
-v      show version
-s      show detailed execution (script tracing)
-e N    show last N program errors
-t N    show trace files for N most recent processes
-o      show documentation directory
-l      show library directory
-m      setup syntax highlighting for Vim
-u      substitute environment variables in stdin
-r      display shell commands to run a program
            --req=\"/<request name><url payload>\"
            --method=\"<request method>\"
            --content=\"<file name>\"
            --content-type=\"<content type>\"
            --exec
            --app=\"application path\" 
            --server
            --remote=\"server IP:port\"
            --socket=\"socket path\"
-q      build application
            --db=\"mariadb:<db name>|postgres:<db name> ...\" 
            --lflag=<linker flags> 
            --cflag=<c flags> 
            --trace 
            --c-lines 
            --posix-regex
            --debug 
            --maxupload=<max upload size>
            --path=\"/some/path\"
            --max-errors=<max errors>
            --plain-diag
-i      display build flags for Vely FastCGI client
            --include
                displays C compile flags
            --link
                displays C linking flags
-a      show release notes for this release
-h      this help
Type 'man vv' for more information.
"
}

#process all command-line options
function main() {



#list of Vely options for getop
_OPT_STATUS="0"
#do NOT use optional :: args - they must always be used as -e3 for example - there can be no space. This is awkward and unwieldy.
_opts=$(getopt -a -n $0 -o ae:t:,q,o,l,m,i,h,c,v,s,u,r --long db:,lflag:,cflag:,trace,plain-diag,posix-regex,asan,asan-opt,content:,content-type:,silent-header,server,remote:,socket:,app:,path:,c-lines,debug,req:,exec,method:,maxupload:,max-errors:,include,link -- "$@") || _OPT_STATUS=$?
if [ $_OPT_STATUS -ne 0 ]; then
    use_message 1>&2
    exit -1
fi

#init flags used to emit helpful messages
_DEVOPT=0
_DO_QUICK=0

#if nothing at all passed that is valid: make vely application - that is just 'vely'
    eval set -- "$_opts"
    while true; do 
    case "$1" in 
        --trace  )
            export VV_C_TRACE="1"
            _DEVOPT=1
            shift 
            ;;
        --c-lines  )
            export VV_C_SKIPLINES="1"
            _DEVOPT=1
            shift 
            ;;
        --plain-diag  )
            export VV_C_PLAINDIAG="1"
            _DEVOPT=1
            shift 
            ;;
        --debug  )
            export VV_C_DEBUG="1"
            _DEVOPT=1
            shift 
            ;;
        --asan-opt  )
            echo "ASAN_OPTIONS=log_path=asan:halt_on_error=0"
            exit 0
            ;;
        --asan  )
            export VV_C_ASAN="1"
            _DEVOPT=1
            shift 
            ;;
#vv -r to talk to server (local socket by default)
        --server  )
            _REQ_SRV="1"
            shift 
            ;;
        --path  )
            export VV_C_RESTPATH="$2"
            _DEVOPT=1
            shift 2
            ;;
        --maxupload  )
            export VV_C_MAXUPLOAD="$2"
            _DEVOPT=1
            shift 2
            ;;
        --max-errors  )
            export VV_C_MAXERRORS="$2"
            _DEVOPT=1
            shift 2
            ;;
        --posix-regex  )
            export VV_C_POSIXREGEX="1"
            _DEVOPT=1
            shift
            ;;
        --cflag  )
            export VV_C_CFLAGS="$2"
            _DEVOPT=1
            shift 2
            ;;
        -t )
#display last N trace files (for N most recent processes)
            _SHOWTRACE="$2"
            shift 2
            ;;
        -u )
#subst env vars from stdin to stdout
            "$VV_LIBRARY_PATH"/v1 -envsub 
            exit 0
            ;;
        -a )
#display release notes
            cat "$VV_LIBRARY_PATH/CHANGELOG"
            shift 1
            exit 0
            ;;
        -e )
#display last N errors from backtrace
            _SHOWERROR="$2"
            shift 2
            ;;
        --lflag  )
            export VV_C_LFLAGS="$2"
            _DEVOPT=1
            shift 2
            ;;
        --content-type  )
#content type
            _REQ_CONTENT_TYPE="$2"
            shift 2
            ;;
        --content  )
            #content file (read from file)
            _REQ_CONTENT="$2"
            shift 2
            ;;
        --silent-header )
#silent-header for --exec
            _REQ_SILENT_HEADER=1
            shift 1
            ;;
        --method  )
#request method (GET, POST...)
            _REQ_METHOD="$2"
            shift 2
            ;;
        --exec  )
#request execute
            _REQ_EXEC="1"
            shift 1
            ;;
        --app  )
#app name (script name) for -r
            _REQ_APP="$2"
            shift 2
            ;;
        --socket  )
#socket for -r --exec
            _REQ_SOCK="$2"
            shift 2
            ;;
        --remote  )
#serverIP:port for -r --exec
            _REQ_IP="$2"
            shift 2
            ;;
        --req  )
#request name+payload 
            _REQ_URL="$2"
            shift 2
            ;;
        -r  )
#display bash to run command-line program
            _COMMRUN="1"
            shift
            ;;
        -h  )
#help message
            use_message
            shift
            exit
            ;;
        -m )
#Vim highlighting
            _DO_HIGHLIGHT="1"
            shift 
            ;;
        --link )
#display FastCGI link
            _DO_CLIENT_LINK="1"
            shift 
            ;;
        --include )
#display FastCGI include
            _DO_CLIENT_INCLUDE="1"
            shift 
            ;;
        -i )
#display FastCGI client flags
            _DO_CLIENT="1"
            shift 
            ;;
        -q )
#quick setup
            _DO_QUICK="1"
            shift 
            ;;
        --db )
#db vendor
            _ALLDB="$2"
            _DEVOPT=1
            shift 2
            ;;
        -c )
#clean the project's temp and object files. This is to be able to fully recompile the project afterwards.
            _DO_CLEAN="1"
            shift 
            ;;
        -d )
#include debugging info in program
            export VV_C_DEBUG="1"
            _DEVOPT=1
            shift 
            ;;
        -l )
#show lib directory
            echo "$VV_LIBRARY_PATH"
            shift 
            exit
            ;;
        -o )
#show documentation directory
            docdir
            shift 
            exit
            ;;
        -s )
#display vely script's execution in detail
            export VV_SHOW_MAKE=
            set -x
            _DEVOPT=1
            shift 
            ;;
        -v )
#display version of Vely
            vely_version
            exit
            ;;
        -- ) 
            shift 
            break
            ;;
        * ) 
            use_message 1>&2
            exit -1
        esac
    done

    #check if old pcre2 lib, use glibc regex
    if [ "$VV_PCRE2_NEW" == "0" ]; then export VV_C_POSIXREGEX="1"; fi

#handle client fastcgi app building
    if [[ "$_DO_QUICK" == "1" && "$_DO_CLIENT" == "1" ]]; then
        error "Cannot use both -i and -q options. Use one or the other"
    fi
    if [ "$_DO_CLIENT" == "1" ]; then
        show_client_bld
        exit 0
    fi

#ask --debug to be used for tracing
    if [[ "$VV_C_TRACE" == "1" && "$VV_C_DEBUG" != "1" ]]; then
        error "In order to use tracing, you must use --debug option"
    fi
#internal: Address Sanitizer only with debug
    if [[ "$VV_C_ASAN" == "1" && "$VV_C_DEBUG" != "1" ]]; then
        error "In order to use ASAN, you must use --debug option"
    fi

#something extra and unexpected, complain about it, probably an error
    if [ "$1" != "" ]; then
        error "Unknown input [$1]"
    fi

#before app name checking b/c it doesn't have anything to do with it
    if [ "$_DO_HIGHLIGHT" != "" ]; then
        setup_highlighting
        exit 0
    fi

#can run this from anywhere if has --req and (--server or --app), otherwise must be in app dir
if [[ "$_COMMRUN" != "" && ("$_REQ_APP" != "" ||  ("$_REQ_SRV" != "" && ("$_REQ_IP" != "" || "$_REQ_SOCK" != "")))  ]]; then
        _TOEXEC=".vely_reqexec"
        #need || true to remove temp file
        show_run_program || true
        rm -f "$_TOEXEC"
        exit 0
    fi

#application name created with vf in .vappname, which must exist
    if [ -f ".vappname" ]; then
        export VV_C_NAME=$(cat .vappname)
    else
        error "Vely application was not created yet. Please use vf to create an application first"
    fi
    check_name "$VV_C_NAME" "application name"
    export VV_BLD0=$VV_DATA/bld
    export VV_BLD=$VV_BLD0/$VV_C_NAME
    export VV_H="$VV_DATA/$VV_C_NAME"
    export VV_A="$VV_H/app"

#THEN perform any actions

#check for source only if compiling or cleaning up
    if [[ "$_DO_QUICK" == "1" || "$_DO_CLEAN" == "1" ]]; then
        _SRCC=$(ls *.vely 2>/dev/null|wc -l)
        if [ "$_SRCC" == "0" ]; then
            error "No Vely source source code found."
        fi
        if [[ ! -d "$VV_A" || ! -d "$VV_BLD" ]]; then
            error "Vely application [$VV_C_NAME] does not exist. Use vf to create it."
        fi
    fi
    if [[ "$_DO_QUICK" == "0" && "$_DEVOPT" == "1" ]]; then
        error "Use -q if you intend to make the application."
    fi

    if [ "$_SHOWERROR" != "" ]; then
        showerr $_SHOWERROR
        exit 0
    fi

    if [ "$_COMMRUN" != "" ]; then
        _TOEXEC="$VV_BLD/.reqexec"
        . $VV_BLD/.blds
        show_run_program
        exit 0
    fi

    if [ "$_SHOWTRACE" != "" ]; then
        showtrace $_SHOWTRACE
        exit 0
    fi

#perform cleaning FIRST. Must 
    if [ "$_DO_CLEAN" == "1" ]; then
        vely_clean
        exit 0
    fi


#perform any actions
#autoapp make app automatically. It exits at its end
    if [ "$_DO_QUICK" == "1" ]; then 
#build app
        autoapp
    fi


#these are 'in-conclusion' actions, they happen LAST
    error "No action specified."
}




#
#
#Functions used in processing
#
#

#
#
#
#Show flags for client FastCGI app building. 
#
#
#
function show_client_bld() {
#if neither --cflag nor --lflag specified, print out both
    if [[ "$_DO_CLIENT_INCLUDE" != "1" &&  "$_DO_CLIENT_LINK" != "1" ]]; then
        _DO_CLIENT_INCLUDE=1
        _DO_CLIENT_LINK=1
    fi
#print the flag asked for, if both, place them on the same line
    if [ "$_DO_CLIENT_INCLUDE" == "1" ]; then
        echo -n "-I$VV_INCLUDE_PATH "
    fi
    if [ "$_DO_CLIENT_LINK" == "1" ]; then
        echo -n "-L$VV_LIBRARY_PATH -lvelyfcli -Wl,--rpath=$VV_LIBRARY_PATH "
    fi
    echo ""
}

#
#
#
#Setup keyword highlighting for Vim
#
#
#
function setup_highlighting() {
    mkdir -p $HOME/.vim
    mkdir -p $HOME/.vim/syntax
    cp $VV_LIBRARY_PATH/v.vim $HOME/.vim/syntax/v.vim
#set .vely file type to use v.vim above
    _USEV="autocmd BufRead,BufNewFile *.vely set filetype=v"
    if [ ! -f "$HOME/.vimrc" ]; then
        echo "$_USEV" > $HOME/.vimrc
    else
        _HERE=$(grep -F "$_USEV" $HOME/.vimrc |wc -l)
        if [ "$_HERE" == "0" ]; then
            echo "$_USEV" >> $HOME/.vimrc
        fi
    fi
#make sure syntax is on
    _SYNON="syntax on"
    _HERE=$(grep -F "$_SYNON" $HOME/.vimrc |wc -l)
    if [ "$_HERE" == "0" ]; then
        echo "$_SYNON" >> $HOME/.vimrc
    fi
}



#
#
#
#Display bash to run command-line program
#
#
#
function show_run_program() {
    if [ "$VV_C_RESTPATH" == "" ];  then
        _APATH="/$VV_C_NAME"
    else
        _APATH="$VV_C_RESTPATH"
    fi
#--app overrides current working directory application above
    if [ "$_REQ_APP" != "" ]; then
        _APATH="$_REQ_APP"
    fi
#get app name from _APATH, it's the last path segment, since _APATH is application path
    _ANAME=$(echo "$_APATH" | awk -F "/" '{print $NF}')
    _REQ_PATH="/<request name><url payload>"
    _REQ_QUERY="<request query>"
    if [ "$_REQ_URL" != "" ]; then
        if [[ "$_REQ_URL" =~ ^.*\?.*$ ]]; then
            _REQ_PATH=$(echo "$_REQ_URL" | cut -d "?" -f 1)
            _REQ_QUERY=$(echo "$_REQ_URL" | cut -d "?" -f 2)
        else
            _REQ_PATH="$_REQ_URL"
            _REQ_QUERY=""
        fi
    fi
    if [ "$_REQ_METHOD" == "" ]; then
        _REQ_METHOD="GET"
    fi
    _CONT=""
    _CONTL=""
    _CONTT="export CONTENT_TYPE="
    _SHEADER="export VV_SILENT_HEADER=no"
    if [ "$_REQ_SILENT_HEADER" == "1" ]; then
        _SHEADER="export VV_SILENT_HEADER=yes"
    fi
    if [[ "$_REQ_CONTENT_TYPE" != "" && "$_REQ_CONTENT" == "" ]]; then
        error "Cannot use --content-type without --content"
    fi
    if [ "$_REQ_CONTENT" != "" ]; then
        if [ ! -f "$_REQ_CONTENT" ]; then
           error "Cannot access file $_REQ_CONTENT"
        fi
        _CONT="cat '$_REQ_CONTENT' | "
        _CONTL="export CONTENT_LENGTH=\$(stat -c%s '$_REQ_CONTENT')"
        if [ "$_REQ_CONTENT_TYPE" != "" ]; then
            _CONTT="export CONTENT_TYPE='$_REQ_CONTENT_TYPE'"
        fi
    else
        _CONTL="export CONTENT_LENGTH="
    fi
    echo "$_CONTT
$_CONTL
$_SHEADER
export REQUEST_METHOD=$_REQ_METHOD
export SCRIPT_NAME=\"$_APATH\"
export PATH_INFO=\"$_REQ_PATH\"
export QUERY_STRING=\"$_REQ_QUERY\""> $_TOEXEC
    if [ "$_REQ_SRV" == "1" ]; then
        if [[ "$_REQ_IP" != "" && "$_REQ_SOCK" != "" ]]; then
            error "Cannot use both --remote and --socket"
        fi
        if [ "$_REQ_IP" != "" ]; then
            echo "${_CONT}cgi-fcgi -connect \"$_REQ_IP\" $_APATH" >> $_TOEXEC 
        else
            if [ "$_REQ_SOCK" != "" ]; then
                if [ ! -S "$_REQ_SOCK" ]; then
                    error "Cannot access socket $_REQ_SOCK or is not a socket file"
                fi
                echo "${_CONT}cgi-fcgi -connect $_REQ_SOCK $_APATH" >> $_TOEXEC 
            else
                echo "${_CONT}cgi-fcgi -connect /var/lib/vv/$_ANAME/sock/sock  $_APATH" >> $_TOEXEC 
            fi
        fi
    else
        if [[ "$_REQ_IP" != "" || "$_REQ_SOCK" != "" ]]; then
            error "Cannot use --remote or --socket without --server"
        fi
        echo "${_CONT}/var/lib/vv/bld/$_ANAME/$_ANAME" >> $_TOEXEC 
    fi
    if [[ "$_REQ_EXEC" == "1" && "$_REQ_URL" == "" ]]; then
        error "Cannot use --exec without --req"
    fi
    if [ "$_REQ_EXEC" == "1" ]; then
       chmod +x $_TOEXEC
       . $_TOEXEC
    else
        cat $_TOEXEC
    fi
}


#
#
#
#Show last $1 trace files
#
#
#
function showtrace() {
    ls -aslrt /var/lib/vv/$VV_C_NAME/app/trace/trace* |tail -n $1
    echo "Backtrace: /var/lib/vv/$VV_C_NAME/app/trace/backtrace"
}

#
#
#
#Show last $1 errors from backtrace
#
#
#
function showerr() {
    grep -a "ERROR:" /var/lib/vv/$VV_C_NAME/app/trace/backtrace |tail -n $1
    echo "Backtrace: /var/lib/vv/$VV_C_NAME/app/trace/backtrace"
}

#
#
#
#Get database vendors and names from dbvendor:dbname ... format, which is the input ($1)
#
#
#
function getdbs() {
#database vendor/name pairs

    _DBL="$1"
    _j=0
    for _i in $(echo "$_DBL"); do
#-n says do not print non-matches, p says print matches only
        _DBV[$_j]=$(sed -n 's/\(.*\):\(.*\)/\1/p' <<<$_i)
        _DBN[$_j]=$(sed -n 's/\(.*\):\(.*\)/\2/p' <<<$_i)
        if [[ "${_DBV[$_j]}" != "mariadb" && "${_DBV[$_j]}" != "postgres" && "${_DBV[$_j]}" != "sqlite" ]]; then
            error "Database [${_DBV[$_j]}] is not supported"
        fi
        if [ "${_DBN[$_j]}" == "" ]; then
            error "Database configuration file not specified"
        fi
        if [[ ! "$_DBVALL" =~ " ${_DBV[$_j]} " ]]; then
            _DBVALL="$_DBVALL ${_DBV[$_j]} "
        fi
        ((_j=_j+1))
    done
}

#
#
#
#Autocreate settings file used to recompile if one (or more) of them changes
#File $VV_BLD/blds is used in vmakefile as a signal to recompile all (if changed)
#Sole purpose is to know when to recompile, nothing is cached as far as command-line params go.
#
#VV_C_MAXERRORS and VV_C_PLAINDIAG do not affect compilation, only the output of errors, so not
#part of mkset.
#
#
function mkset() {
    echo "VV_C_TRACE='$VV_C_TRACE'
VV_C_SKIPLINES='$VV_C_SKIPLINES'
VV_C_ASAN='$VV_C_ASAN'
VV_C_DEBUG='$VV_C_DEBUG'
VV_C_MAXUPLOAD='$VV_C_MAXUPLOAD'
VV_C_RESTPATH='$VV_C_RESTPATH'
VV_C_CFLAGS='$VV_C_CFLAGS'
VV_C_LFLAGS='$VV_C_LFLAGS'
VV_C_POSIXREGEX='$VV_C_POSIXREGEX'
VV_C_MODULES='$VV_C_MODULES'
VV_C_V1_MOD='$(stat -c "%Y" $VV_LIBRARY_PATH/v1)'
VV_C_VV_MOD='$(stat -c "%Y" $(which vv))'
VV_DBS='$_ALLDB'
" > $VV_BLD/.blds
    if [ ! -f "$VV_BLD/blds" ]; then
        cp -f $VV_BLD/.blds $VV_BLD/blds
    else
        _ECODE="0"
        diff $VV_BLD/.blds $VV_BLD/blds > /dev/null || _ECODE="$?"
        if [ "$_ECODE" != 0 ]; then
            cp -f $VV_BLD/.blds $VV_BLD/blds
        fi
    fi
}


#
#
#
#Show documentation directory
#
#
#
function docdir() {
    if [ "$VV_ISFEDORA" == "1" ]; then
        echo "$(rpm -E '%{_datadir}')/vely"
    elif [ "$VV_ISDEBIAN" == "1" ]; then
        echo "/usr/share/vely"
    elif [ "$VV_ISARCH" == "1" ]; then
        echo "/usr/share/vely"
    else
        error "Unknown Operating System"
    fi
}

#
#
#
#Check if app name is valid
#
#
#
function check_name() {
#$1 is the name
#$2 is the type of it (used in error message)
    if [[ ! "$1" =~ ^[a-zA-Z0-9_]{1,30}$ ]]; then
        error "$2 name can be made up of alphanumerical characters only and underscore, and its length must be between 1 and 30 characters, found [$1]"
    fi
}



#
#
#
#Emitting error messages
#
#
#
function error() {
#$1 is message
    echo -e "** Error: $1" 1>&2
    exit -1
}




#
#
#if VV_C_MODULES read from .cache file and available, get the usage and set modules
#
#
function read_modules() {

#Set _ISMOD_* variables and call set_modules to set variables for building of application.
    for _i in $(echo "$VV_C_MODULES"); do
        if [ "$_i" == "mariadb" ]; then
            _ISMOD_MARIADB="1"
        elif [ "$_i" == "postgres" ]; then
            _ISMOD_POSTGRES="1"
        elif [ "$_i" == "sqlite" ]; then
            _ISMOD_SQLITE="1"
        else
            error "Unknown module [$_i]"
        fi
    done

#
#begin automatic libs discovery
#
#figure out if there's need for these libs
#these find out if there's mention of these calls. A more native C approach was attempted
#where during v1 compilation, information was collected and then used later, however that method ended up being either same or 
#slower than this due to complexities of collecting and manipulating, and having to change (now) simple Makefile rules.
#Trying to obtain modification times, save and compare later was alone more than double the time of what's below.
#This gives all files to grep, so avoid slow "for i in $(ls *.vely)", and checks for file that has other than filename:0, so
#that's where :[1-9] comes from. By far the fastest method.
#Overall, the slowdown in performance of full recompile with this is only about 0.06% for 67 .vely files and about 8000 lines of code.
#The limit here is about 100,000 file with names of 20 chars long, so unlikely to have that many source files with that long names
#This approach also scales the best. For example, adding 10 more libs put it at 0.4%, whereas the approach with grepping
#each lib separately puts it at 0.74%, or almost double.
#

#first look for all possible statements
    grep -h -o "^[[:space:]]*\(call-web \|match-regex \|hash-string \|decrypt-data \|encrypt-data \|decode-base64 \|encode-base64 \|random-crypto \|new-server \)" *.vely>$VV_BLD/.findmod || true
#then from occurrances, look for curl
    if [[ $(grep -m 1 -o "^[[:space:]]*call-web " $VV_BLD/.findmod) != "" ]]; then _ISMOD_CURL="1"; fi
#then from occurrances, look for pcre2
    if [[ $(grep -m 1 -o "^[[:space:]]*match-regex " $VV_BLD/.findmod) != "" ]]; then _ISMOD_PCRE2="1"; fi
#then from occurrances, look for fcgi
    if [[ $(grep -m 1 -o "^[[:space:]]*new-server " $VV_BLD/.findmod) != "" ]]; then _ISMOD_FCGI="1"; fi
#then from occurrances, look for crypto
    if [[ $(grep -m 1 -o "^[[:space:]]*\(hash-string \|decrypt-data \|encrypt-data \|decode-base64 \|encode-base64 \|random-crypto \)" $VV_BLD/.findmod) != "" ]]; then _ISMOD_CRYPTO="1"; fi


#
#end automatic libs discovery
#

    VV_MOD_LIBS=
    VV_MODULES=
    VV_MODULES_INCLUDE=
    VV_STUBS=
    VV_LIST_ALL_MODULES=
#sqlite module
    if [ "$_ISMOD_SQLITE" == "1" ]; then
        VV_SQLITE_USED="-DVV_SQLITE_INCLUDE"
#sqlite3.h is installed in include directory, so no need to specify
        #VV_MODULES_INCLUDE="$VV_MODULES_INCLUDE -I /usr/include/sqlite3.h"
        VV_MODULES="$VV_MODULES -lsqlite3"
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelylite"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES sqllite"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_sqlite.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES sqlite"
    fi
#postgres module
    if [ "$_ISMOD_POSTGRES" == "1" ]; then
        VV_POSTGRES_USED="-DVV_POSTGRES_INCLUDE"
        VV_C_PGCONF=$(. "$VV_LIBRARY_PATH"/sys pgconf)
        if [ "$VV_C_PGCONF" == "yes" ]; then
            VV_MODULES_INCLUDE="$VV_MODULES_INCLUDE -I $(pg_config --includedir)"
        else
            VV_MODULES_INCLUDE="$VV_MODULES_INCLUDE $(pkg-config --cflags libpq)"
        fi
        VV_MODULES="$VV_MODULES -lpq"
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelypg"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES postgres"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_postgres.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES postgres"
    fi
#mariadb module
    if [ "$_ISMOD_MARIADB" == "1" ]; then
        VV_MARIADB_USED="-DVV_MARIADB_INCLUDE"
        VV_MODULES_INCLUDE="$VV_MODULES_INCLUDE $(mariadb_config --include)"
        VV_MODULES="$VV_MODULES $(mariadb_config --libs)"
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelymys"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES mariadb"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_mariadb.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES mariadb"
    fi
#fcgi module
    if [ "$_ISMOD_FCGI" == "1" ]; then
        VV_FCGI_USED="-DVV_FCGI_INCLUDE"
        #VV_MODULES="$VV_MODULES -lfcgi" - nothing here since fcgi client implemented from scratch
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelyfsrv"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES fcgi"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_fcgi.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES curl"
    fi
#pcre2 module
    if [ "$_ISMOD_PCRE2" == "1" ]; then
        #this is if not using plain posix regex, otherwise nothing to do
        if [ "$VV_C_POSIXREGEX" != "1" ]; then
            VV_PCRE2_USED="-DVV_PCRE2_INCLUDE"
            VV_MODULES="$VV_MODULES $VV_PCRE2_LIBS"
            VV_MOD_LIBS="$VV_MOD_LIBS -lvelypcre2 -ldl"
            VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES pcre2"
        else
            #pcre is not used, but we still use glibc regex, so include regex.h and compile pcre2.c (which does both
            #glibc and pcre2)
            VV_PCRE2_USED="-DVV_PCRE2_INCLUDE"
            VV_MOD_LIBS="$VV_MOD_LIBS -lvelypcre2glibc -ldl"
            VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES pcre2"
        fi
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_pcre2.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES pcre2"
    fi
#curl module
    if [ "$_ISMOD_CURL" == "1" ]; then
        VV_CURL_USED="-DVV_CURL_INCLUDE"
        VV_MODULES="$VV_MODULES -lcurl"
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelycurl"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES curl"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_curl.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES curl"
    fi
#crypto module
    if [ "$_ISMOD_CRYPTO" == "1" ]; then
        VV_CRYPTO_USED="-DVV_CRYPTO_INCLUDE"
        VV_MODULES="$VV_MODULES -lssl -lcrypto"
        VV_MOD_LIBS="$VV_MOD_LIBS -lvelysec"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES crypto"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_crypto.o"
        VV_LIST_ALL_MODULES="$VV_LIST_ALL_MODULES crypto"
    fi
    if [[ "$_ISMOD_MARIADB" == "1" || "$_ISMOD_POSTGRES" == "1" || "$_ISMOD_SQLITE" == "1"  ]]; then
        VV_MOD_LIBS="-lvelydb $VV_MOD_LIBS"
    else
        VV_STUBS="$VV_STUBS $VV_LIBRARY_PATH/stub_gendb.o"
    fi


#used in vmakecommon/install to properly link modules at link-time and to substitute stubs for those modules that are not used
    export VV_MODULES
    export VV_MODULES_INCLUDE
    export VV_STUBS
    export VV_MOD_LIBS
    export VV_C_MODULES
    export VV_LIST_ALL_MODULES
    export VV_MARIADB_USED
    export VV_FCGI_USED
    export VV_CURL_USED
    export VV_PCRE2_USED
    export VV_CRYPTO_USED
}

#
#
#
#make generated files affect recompilation ONLY if they are different
#
#
#
function copy_if_diff () {
    F="$1"
    _ISDIFF=$(diff $VV_BLD/$F.new $VV_BLD/$F 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$VV_BLD/$F" ]]; then
        mv $VV_BLD/$F.new $VV_BLD/$F
    else
        rm -rf $VV_BLD/$F.new
    fi
}



#
#
#sets a list of many source code files (source.vely, velyapp.h, vely_dispatch_request.vely etc.)
#takes care of generated vs provided source code: if a certain handler is provided, then don't generate it.
#
#
function gen_src() {

#
#Files generated here are $VV_BLD/source.vely,velyapp.h,vely_dispatch_request.vely.
#

#
#Generate source.vely, all the source files needed for Vely app
#
    _T="source.vely"
#this is all source files, including non-request ones
    _SRCF=$(ls *.vely 2>/dev/null) || true
    _HDRF=$(ls *.h 2>/dev/null) || true

    echo "#SPDX-License-Identifier: EPL-2.0" >> $VV_BLD/$_T.new
    echo "#Copyright 2019 DaSoftver LLC. Written by Sergio Mijatovic." >> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    echo "#" >> $VV_BLD/$_T.new
    echo "#Lists source files in your application. This is an auto-generated file." >> $VV_BLD/$_T.new
    echo "#" >> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    echo "#Include files here:" >> $VV_BLD/$_T.new
    _HFILES=$(echo "$_HDRF" | grep -a -v velyapp.h | xargs)
    echo "VV_HEADER_FILES=$(echo $_HFILES)" >> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    echo "#Source files here:" >> $VV_BLD/$_T.new
    echo "VV_SOURCE_FILES=$(echo $_SRCF)" >> $VV_BLD/$_T.new

    _ISDIFF=$(diff $VV_BLD/$_T.new $VV_BLD/$_T 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$VV_BLD/$_T" ]]; then
        mv $VV_BLD/$_T.new $VV_BLD/$_T
    else
        rm -rf $VV_BLD/$_T.new
    fi



#
#Generate velyapp.h, a file that has a list of C declarations neeeded to build an app
#
    _T="velyapp.h"

    echo "// SPDX-License-Identifier: EPL-2.0"  >> $VV_BLD/$_T.new
    echo "// Copyright 2019 DaSoftver LLC. Written by Sergio Mijatovic.">> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    echo "// This is an auto-generated file for a VELY application" >> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    echo "#ifndef _VELYAPP" >> $VV_BLD/$_T.new
    echo "#define _VELYAPP" >> $VV_BLD/$_T.new
    echo >> $VV_BLD/$_T.new
    if [ "$_HFILES" != "" ]; then
        echo "$_HFILES" | sed 's/\(.*\)/#include "\1"/g' >> $VV_BLD/$_T.new
        echo >> $VV_BLD/$_T.new
    fi
    echo "// function prototypes of your code" >> $VV_BLD/$_T.new
#declare all functions, including non-request ones (whether implemented or not)
    for _F in $(echo $_SRCF); do
        _FN=${_F%.*}
        echo "void ${_FN}();" >> $VV_BLD/$_T.new
    done
    echo >> $VV_BLD/$_T.new
    echo "#endif" >> $VV_BLD/$_T.new

    _ISDIFF=$(diff $VV_BLD/$_T.new $VV_BLD/$_T 2>/dev/null) || true
    if [[ "$_ISDIFF" != "" || ! -f "$VV_BLD/$_T" ]]; then
        mv $VV_BLD/$_T.new $VV_BLD/$_T
    else
        rm -rf $VV_BLD/$_T.new
    fi

#
#Generate vely_dispatch_request.vely, the main request handler. Based on the source code names of handler files (.vely files)
#
    _T="vely_dispatch_request.vely"
#Generate request files, this means NO non-request files, since this is used for a dispatcher
#and for a dispatcher, only request files matter (R is for request files in _SRCFR and _NUMFR)
    _SRCFR=$(echo "$_SRCF" | grep -a -v "^_.*\.vely") || true
    _NUMFR=$(echo $_SRCFR | wc -w)

    echo "// SPDX-License-Identifier: EPL-2.0" >>$VV_BLD/$_T.new
    echo "// Copyright 2019 DaSoftver LLC. Written by Sergio Mijatovic." >>$VV_BLD/$_T.new
    echo >>$VV_BLD/$_T.new
    echo "// VELY auto-generated request dispatcher" >>$VV_BLD/$_T.new
    echo >>$VV_BLD/$_T.new
    echo "#include \"vely.h\"" >>$VV_BLD/$_T.new
    echo >>$VV_BLD/$_T.new
    echo "void vely_dispatch_request()" >>$VV_BLD/$_T.new
    echo "{" >>$VV_BLD/$_T.new

#longjmp for when a request exits via exit-request. If return value is <>0, it means
#this is a call from longjmp, and we should proceed to right after vely_dispatch_request - that is the extent
#of unwinding, such that we rollback uncommitted transactions, shutdown request and release all memory and
#then move on to the next request.
#Cannot place setjmp within if, may not process correctly when jump happens.
#We use vely_done_setjmp to prohibit exit-request from executing the jump unless sigsetjmp was done first at runtime.
    echo "    int ret_val = sigsetjmp(vely_jmp_buffer, 1);" >>$VV_BLD/$_T.new
    echo "    if (ret_val != 0) goto end_point_exit;" >>$VV_BLD/$_T.new
    echo "    vely_done_setjmp = 1;" >>$VV_BLD/$_T.new
#right now the return value is always 0 (directly or called from longjmp)
#the jump will work because all we do is go to _after() function, which doesn't depend on any
#automatic variables from vely_dispatch_request, and after that function exits

#req_done used to skip before/after execution if no handler used
    echo "    volatile int req_done;" >>$VV_BLD/$_T.new #volatile because of longjmp, so the init below doesn't get optimized

    if [ "$_NUMFR" != "0" ]; then
        echo "    get-req name to define req" >>$VV_BLD/$_T.new
    fi
    echo "    .req_done = 0;" >>$VV_BLD/$_T.new #must be initialized separately (not as int req_done=0;) because longjmp may return to the same function and won't be initialized again
#create file with all request names for v1 to process for the main function code. This way all request info is stored as constants to be loaded as program's data, meaning the fastest possible in huge memory blocks, without having to set up each individually
#first line is the number of lines that follow, to make code generation easier
    echo $_NUMFR > $VV_BLD/.reqlist.new
    _F_FIRST=""
    for _F in $(echo $_SRCFR); do
        _FN=${_F%.*}
        if [ "$_F_FIRST" == "" ]; then _F_FIRST="$_FN"; fi
        echo "$_FN " >>$VV_BLD/.reqlist.new
    done
    echo "  vely_request_handler _vv_req_handler;" >>$VV_BLD/$_T.new
    if [ "$_NUMFR" == "1" ]; then
        echo "    if (!strcmp (req, \"$_F_FIRST\") || req[0] == 0) _vv_req_handler = $_F_FIRST; else _vv_req_handler = NULL;" >>$VV_BLD/$_T.new
    else
#get handler function that handles this request from the pre-computed hash
        echo "    _vv_req_handler = vely_find_hash (&vv_dispatch, req, NULL, 0, NULL, NULL);" >>$VV_BLD/$_T.new
    fi
#before handler executes only IF req found a handler, that's why it's not in front of if()
    echo "      if (_vv_req_handler != NULL) {" >>$VV_BLD/$_T.new
    echo "        ._before();" >>$VV_BLD/$_T.new
    echo "        .vely_mem_os = false;" >>$VV_BLD/$_T.new
    echo "        .req_done = 1;" >>$VV_BLD/$_T.new
    echo "        ._vv_req_handler();" >>$VV_BLD/$_T.new
    echo "    } else {" >>$VV_BLD/$_T.new
    echo "        vely_bad_request();" >>$VV_BLD/$_T.new
    echo "        vely_report_error (\"Request [%s] not found\", req);" >>$VV_BLD/$_T.new
    echo "    }" >>$VV_BLD/$_T.new

#when exit-request is done, this is where we must end up. Since this code is executed after
#vely_dispatch_request, we can't longjump here. We long jump to a prior point and then go to here.
    echo ".end_point_exit:" >>$VV_BLD/$_T.new
#set vely_done_setjmp to 0, because if we do exit-request in _after(), it would go into infinite loop, coming back to after.
#this way, exit-request in _after, or anywhere afterwards, will do nothing. Only when the next request comes along, and vely_done_setjmp is set to 1
#in the beginning of this function, we will actually jump to end_point_exit:
    echo "    .vely_done_setjmp = 0;" >>$VV_BLD/$_T.new
#regardless of whether a request normally ended, or had exit-request, it would come here, and before anything else, memory handling must be set back
#to Vely, or otherwise, and vely_* memory function will fail if set to true. _after() should not be affected by type of memory used.
    echo "    .vely_mem_os = false;" >>$VV_BLD/$_T.new

#cannot do exit-request in _after - must simply do return(s)
    echo "    .if (req_done == 1) { _after(); vely_mem_os = false; }" >>$VV_BLD/$_T.new
#
#There can be NOTHING after .after() that uses any automatic variables from vely_dispatch_request() or
#exit-request (and longjmp) will not work
#
    echo "}" >>$VV_BLD/$_T.new
    echo >>$VV_BLD/$_T.new

    copy_if_diff "$_T"
    copy_if_diff ".reqlist"
}



#
#
#
#Create linkage for before,after and startup events. _weak_ linkage didn't work because Vely should produce
#a program that links *only* with Vely libs. It means we only distribute a single file, which is a program,
#that has only the minimal set of code - and this program uses Vely's shared library. Hence, all is shared 
#(the program between different instance and all the shared libs).
#VV_EVENT_STUBS is all the stubs used.
#So, VV_EVENT_STUBS could be "/usr/lib/vely/stub_after.o" but then available after vmakefile will be "$VV_BLD/_before.o $VV_BLD/startup.o"
#and all three will be present (one empty and two implemented)
#
#
#
function stub_events() {
    VV_EVENT_STUBS=
    if [ ! -f "_before.vely" ]; then
        VV_EVENT_STUBS="$VV_EVENT_STUBS $VV_LIBRARY_PATH/stub_before.o"
    fi
    if [ ! -f "_after.vely" ]; then
        VV_EVENT_STUBS="$VV_EVENT_STUBS $VV_LIBRARY_PATH/stub_after.o"
    fi
    if [ ! -f "_startup.vely" ]; then
        VV_EVENT_STUBS="$VV_EVENT_STUBS $VV_LIBRARY_PATH/stub_startup.o"
    fi
    export VV_EVENT_STUBS
}


#
#
#
#Build Vely app
#
#
#
function build_app() {
    _VFILES=$(ls *.vely 2>/dev/null|wc -l) 
    if [ "$_VFILES" == "0" ]; then error "Your project must have at least one .vely file"; fi
#set .dbvendors for v1 to pickup
    db_lib
#get any modules in use, and generate a list of all modules
    read_modules
#generate needed source code
    gen_src
#generate stubs (if needed) for events (before, after, startup..)
    stub_events
#create file that tells make to recompile if options changed
    mkset
#make the application (compile and link)
    make $VV_SHOW_MAKE  -f "$VV_LIBRARY_PATH"/vmakefile all
}

#
#
#
#Command line options implementation
#
#
#

function vely_version() {
#the final year is based on the year when the last Makefile ran, which is a pretty good indicator of when was the last change done here by the author;
#of course, for those who compile from source, and don't use the provided deb/dnf packages, it will always be the current year - that is not the intention -
#in that case, change this manually to the year from the official distribution!!!! That is required under most copyright laws, in which the second year should
#be the year of the last change by the author.
    echo "Vely $VV_VERSION$_BETA on $VV_PLATFORM_ID ($VV_PLATFORM_VERSION)"
    echo "Copyright (c) 2019-$(date '+%Y') Dasoftver LLC"

}

#
#
#
#display file or empty string if it doesn't exist
#
#
#
function cat0() {
    if [ ! -f "$1" ]; then echo ""; else cat "$1"; fi
}



#
#
#
#Quick auto app maker
#
#
#
function autoapp() {

    build_app 
    exit
}


#
#
#
#Set library modules from --db. Either db_lib (-q) or init_db (-qa) is executed, but not both
#
#
#
function db_lib() {
#parse --db input
#get list of dbs - add any new db vendors here (currently mariadb and postgres)
    rm -f $VV_BLD/.dbvendors
    getdbs "$_ALLDB"
    _TOTDB="${#_DBV[@]}"
    for (( _i=0; _i<$_TOTDB; _i++ )); do
#must copy array element 
        _DBNAME="${_DBN[$_i]}"
        _DBCONF="$_DBNAME"
#build list of all
        _ALLC="$_ALLC
$_DBCONF"
        _DBMAKE="${_DBV[$_i]}"
        if [ "$_DBMAKE" == "sqlite" ]; then
            if [ "$_DONELITE" == "" ]; then
                export VV_C_MODULES="$VV_C_MODULES $_DBMAKE"
                _DONELITE="1"
            fi    
#for v1.c to pick up
            echo "${_DBCONF}=sqlite" >> $VV_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$VV_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $VV_A/db/"$_DBCONF"
        fi
        if [ "$_DBMAKE" == "mariadb" ]; then
            if [ "$_DONEMARIA" == "" ]; then
                export VV_C_MODULES="$VV_C_MODULES $_DBMAKE"
                _DONEMARIA="1"
            fi    
#for v1.c to pick up
            echo "${_DBCONF}=mariadb" >> $VV_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$VV_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $VV_A/db/"$_DBCONF"
        fi
        if [ "$_DBMAKE" == "postgres" ]; then
            if [ "$_DONEPG" == "" ]; then
                export VV_C_MODULES="$VV_C_MODULES $_DBMAKE"
                _DONEPG="1"
            fi
#for v1.c to pick up
            echo "${_DBCONF}=postgres" >> $VV_BLD/.dbvendors
            if [ ! -f "$_DBCONF" ]; then
                error "Database configuration file [$_DBCONF] ($_DBMAKE) not found"
            fi
            "$VV_LIBRARY_PATH"/v1 -envsub < "$_DBCONF" > $VV_A/db/"$_DBCONF"
        fi
    done
#check db conf name unique
    _TUNIQ=$(echo $_ALLC|sort -k 1|uniq|wc -l)
    _TOT=$(echo $_ALLC|wc -l)
    if [ "$_TUNIQ" != "$_TOT" ]; then
        error "Database configuration names must be unique"
    fi
}



#
#
#
#Clean building artifacts of Vely code to rebuilt it entirely
#
#
#
function vely_clean() {
#clean the source and other code, so the next vely app compilation will be a full rebuild
    make $VV_SHOW_MAKE -f "$VV_LIBRARY_PATH"/vmakefile clean
}


main "$@"



